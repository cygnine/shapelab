function[w]= evaluate_inverse_map(z,mapdata,varargin)
% [w]= evaluate_inverse_map(z,mapdata,{boundary=false})
%
%     Input mapdata contains:
%            a_array
%            z_initial
%            zeta_n
%            normalization
%
%     Evaluates the inverse of the conformal map generated by the `geodesic
%     algorithm', specified by the data z_initial, a_array, and zeta_n. See
%     compute_map_coordinates and [1] for details of what these inputs are. The
%     output w is the map evaluated at the input locations z. normalization
%     specifies the normalization to be taken for the conformal map. 
%
%     [1]: Marshall and Rohde, "Convergence of the Zipper algorithm for
%          conformal mapping", 2006.

global handles;
opt = handles.common.InputSchema({'boundary'}, {false}, [], varargin{:});
ifa = handles.shapelab.conformal_mapping.geodesic.inverse_base_conformal_map;
moebius = handles.shapelab.common.moebius;
dab = handles.shapelab.common.disc_a_to_b;
csqrt = handles.shapelab.common.positive_angle_square_root;

[z_initial, a_array, a_cut_bias, normalization_persistence, zeta_n, normalization] = ...
  deal(mapdata.z_initial, mapdata.a_array, mapdata.a_cut_bias, ...
    mapdata.normalization_persistence, mapdata.zeta_n, mapdata.normalization);

% Un-normalize
w = dab(z, normalization(2), normalization(1));

% Map from unit circle to half-plane
w = moebius(w, [i -i; -1 -1]);
if opt.boundary
  w = real(w);
end

% Invert terminal map
w = csqrt(-w,'cut_bias', false);
w = moebius(w, [1 0; 1/zeta_n 1]);

% Invert sequential maps
for q = length(a_array):-1:1
  if q<=length(a_array) && normalization_persistence(q)~=0
    w = w/normalization_persistence(q);
  end
  w = ifa(w,a_array(q));
end

% Invert initial map
w = (w/i).^2;
w = moebius(w, [-z_initial(1) z_initial(2); -1 1]);
